*** JavaScript Introduction ***


1. JavaScript is a versatile, high-level programming language that is widely supported across all major operating systems.

2. A JavaScript variable is a container for storing data.

3. we use the var or let keywords to declare variables. 
var : function-scoped, let : block-scoped, const : block-scoped.

4. A constant (const) is a type of variable whose value cannot be changed.
If you do not initialize a constant at the time of declaration, it throws an error.

5. console.log() method displays messages or variables in the browser's console.

6. There are altogether 8 basic data types in JavaScript.
Primitive Data Types: They can hold a single simple value. String, Number, BigInt, Boolean, undefined, null, and Symbol are primitive data types.
Non-Primitive Data Types: They can hold multiple values. Objects are non-primitive data types.

7. A string represents textual data. It contains a sequence of characters. For example, "hello", "JavaScript", etc.
strings are surrounded by quotes:
Single quotes: 'Hello'
Double quotes: "Hello"
Backticks: `Hello`

8.the number type represents numeric values (both integers and floating-point numbers).
JavaScript can also represent special numeric values such as Infinity, -Infinity, and NaN (Not-a-Number). For example,

let number1 = 3 / 0;
console.log(number1);  // Infinity

let number2 = -3 / 0;
console.log(number2);  // -Infinity

// strings can't be divided by numbers
let number3 = "abc" / 3; 
console.log(number3);  // NaN

9. BigInt is a type of number that can represent very large or very small integers beyond the range of the regular number data type.
The regular number data type can handle values less than (2^53 - 1) and greater than -(2^53 - 1).
A BigInt number is created by appending n to the end of an integer. For example,
// BigInt value
let value1 = 900719925124740998n;

// add two big integers
let result1 = value1 + 1n;
console.log(result1);  // "900719925124740999n"

let value = 900719925124740998n;;
let sum = value + 1; 
console.log(sum);
Output : TypeError: Cannot mix BigInt and other types, use explicit conversions

10.A Boolean data can only have one of two values: true or false.
Except these 6 values, all values are truthy values :
false, undefined, null, NaN, '', 0
built-in boolean methods :
toString()	returns a boolean value by converting boolean to a string
valueOf()	returns the primitive value of a boolean

The Boolean() function is used to convert various data types to boolean values. 
let result;
result = 20;
console.log(Boolean(result)); // true
console.log(typeof Boolean(result)); // boolean
result = Boolean('');
console.log(result); // false

You can also create a boolean value using the new keyword. For example,
const a = true;

// creating a boolean object
const b = new Boolean(true);

console.log(a); // true
console.log(b); // true

console.log(typeof a); // "boolean"
console.log(typeof b); // "object"

It is recommended to avoid using boolean objects. Using boolean objects slows down the program.

Boolean(expression) will simply convert the expression into a boolean primitive value, while new Boolean(expression) will create a wrapper object around the converted boolean value.

11. If a variable is declared but the value is not assigned, then the value of that variable will be undefined. 
let name = undefined;
console.log(name);  // undefined
You should avoid explicitly assigning undefined to a variable. Usually, we assign null to variables to indicate "unknown" or "empty" values.

12. null represents "no value" or "nothing." 
const a = null;
console.log(typeof a); // object

let a;
console.log(typeof a); // undefined

when you pass undefined to a function parameter that takes a default value, the undefined is ignored and the default value is used.

when you pass undefined to a function parameter that takes a default value, the undefined is ignored and the default value is used.

console.log(null == undefined); // true
console.log(null === undefined); // false

12. A Symbol is a unique and primitive value. This data type was introduced in ES6.
When you create a Symbol, JavaScript guarantees that it is distinct from all other symbols, even if they have the same descriptions. For example,
// two symbols with the same description
let value1 = Symbol("programiz");
let value2 = Symbol("programiz");
console.log(value1 === value2);  // false

To access the description of a symbol, we use the . operator. 
const x = Symbol('hey');
console.log(x.description); // hey

You can add symbols as a key in an object using square brackets [].
let id = Symbol("id");
let person = {
    name: "Jack",
    // adding symbol as a key
    [id]: 123 // not "id": 123
};
console.log(person); // {name: "Jack", Symbol(id): 123}

The for...in loop does not iterate over Symbolic properties. 

If the same code snippet is used in various programs, then it is better to use Symbols in the object key. It's because you can use the same key name in different codes and avoid duplication issues. 

13. An Object holds data in the form of key-value pairs. For example,
let student = {
    firstName: "John",
    lastName: null,
    class: 10
};

14. the typeof operator to find the data type of a variable.
typeof returned object for the null type. This has been a known issue in JavaScript since its first release.

JavaScript determines the type of a variable based on the value assigned to it.
As a result, changing the value of a variable can also change its type, provided the new value is of a different type.

14. JavaScript operators are special symbols that perform operations on one or more operands (values). we used the + operator to add the operands 2 and 3.

Here is a list of different JavaScript operators :
Arithmetic Operators : + , - , * , / , % , ++ , -- , **
Assignment Operators : + , += , -= , *= , /= , %= , **=
Comparison Operators : == , != , > , < , >= , <= , === , !==
Logical Operators : && , || , !
Bitwise Operators : & , | , ^ , ~ , << , >> , >>>
String Concatenation Operators : +
Miscellaneous Operators : , (comma) , ? : , typeof , instanceof , void

... : spread and rest operator.

% : Remainder Operator, %= : Remainder Assignment Operator
If you use the ++ operator as a prefix like: ++var, the value of var is incremented by 1; then it returns the value.
If you use the ++ operator as a postfix like: var++, the original value of var is returned first; then var is incremented by 1. (same for decrement -- also).

a > b is called a boolean expression since evaluating it results in a boolean value.

The equality operators (== and !=) convert both operands to the same type before comparing their values.
However, the strict equality operators (=== and !==) do not convert operand types before comparing their values. 

We use logical operators to perform logical operations on boolean expressions.

We use bitwise operators to perform binary operations on integers.

Comma (,) : Evaluates multiple operands and returns the value of the last operand.
let a = (1, 3, 4);  // 4;

instanceof : Returns true if the specified object is a valid object of the specified class.

void : Discards any expression's return value.
The void operator evaluates the given expression and then returns undefined.


15. JavaScript comments are annotations in the code that are completely ignored by the compiler. 
// - Single-Line Comments
/* */ - Multiline Comments

use comments to explain why you did something rather than how you did something.

16. type conversion is the process of converting data of one type to another. For example, converting string data to number.

JavaScript Implicit Conversion :
JavaScript automatically converts data of one type to another (to the right type). This is known as implicit conversion.
// numeric string used with + gives string type
let result;

// convert number to string
result = "3" + 2; 
console.log(result, "-", typeof(result));

result = "3" + true; 
console.log(result, "-", typeof(result));

result = "3" + null; 
console.log(result, "-", typeof(result));

Output :
32 - string
3true - string
3null - string

JavaScript Explicit Conversion :
n explicit type conversion, you manually convert one type of data into another using built-in functions. 
let result;

// convert string to number
result = Number("5");
console.log(result, "-", typeof(result));

// convert boolean to string
result = String(true);
console.log(result, "-", typeof(result));

// convert number to boolean
result = Boolean(0);
console.log(result, "-", typeof(result));

Output :
5 - number
true - string
false - boolean

When you use arithmetic operators like -, *, /  or % with numeric strings, 
JavaScript automatically changes those strings into numbers.

Operations involving binary + will convert numbers to strings in the case of string and number concatenation.
Logical operations convert operands to boolean values.
When subtracting a string from another string, JavaScript attempts to convert both strings to numbers.
When you change an object's type, some data might get lost.


*** JavaScript Control Flow ***

17. The JavaScript if...else statement is used to execute/skip a block of code based on a condition.
We can omit { } in if…else statements when we have a single line of code to execute.
We can replace our if…else statement with the switch statement when we deal with a large number of conditions.
switch is faster than long chains of if…else statements.

18. for loop is used for iterating over a block of code a certain number of times, or to iterate over the elements of an array.
for (initialExpression; condition; updateExpression) {
    // for loop body
}
Nested for Loops :
A for loop can also have another for loop inside it. For each cycle of the outer loop, the inner loop completes its entire sequence of iterations. 

In JavaScript, we can create an infinite for loop by setting a condition that always evaluates to true.
for (let i = 0; true; i++) {
    console.log("This loop will run forever!");
}
Creating an infinite loop is something that we should generally avoid, as it will consume all available resources to execute the loop endlessly.

We can omit any part of the for loop declaration and include it in a different part of the code.
// initialization outside the loop
let i = 0;
// omit initialization and update statements
for (; i < 3; ) {
    console.log(`i is ${i}`);
    // increment inside the loop body
    i++; 
}

19. The while loop repeatedly executes a block of code as long as a specified condition is true.
while (condition) {
    // body of loop
}

The do...while loop executes a block of code once, then repeatedly executes it as long as the specified condition is true.
do {
    // body of loop
} while(condition);

difference between for and while loops :
We use a for loop when we need to perform a fixed number of iterations. 
Meanwhile, we use a while loop when the termination condition can vary. 

20. The break statement terminates the loop immediately when it's encountered.
The break statement is usually used inside decision-making statements such as if...else.
When break is used inside two nested loops, it terminates the inner loop.
When using nested loops, we can terminate the outer loop with a labeled break statement.
We can also use the break statement within a switch statement to terminate a case. 

21. The continue statement skips the current iteration of the loop and proceeds to the next iteration.

The continue statement is usually used inside decision-making statements such as if...else.

When continue is used inside two nested loops, continue affects only the inner loop. 

22. The JavaScript switch...case statement executes different blocks of code based on the value of a given expression.
The default case is optional.
The break statement terminates the execution of switch-case once a matching case has been found.
Without break, the program would continue executing subsequent cases even after finding a match. 
Sometimes, we may want multiple case values to trigger the same block of code. For this, we can use multiple cases with a single block.
let age = 19;
switch (age) {
    // when age is 13, 14, or 15
    case 13:
    case 14:
    case 15:
        console.log("Early Teen")
        break;
    // when age is 16 or 17
    case 16:
    case 17:
        console.log("Mid Teen");
        break;
}

switch statement performs type checking, ensuring both the value and the type of the expression match the case value. 

Use switch for a large number of conditions based on the same expression, which can be more readable than if...else.
Use if...else for complex logical conditions that can't be easily expressed as discrete cases.


*** Functions ***

23. A function is an independent block of code that performs a specific task, while a function expression is a way to store functions in variables.

A function argument is the value we pass to the function, while a function parameter is a placeholder that stores the argument passed to the function.

We can pass different arguments in each call, making the function re-usable and dynamic.

JavaScript Library Functions
JavaScript provides some built-in functions that can be directly used in our program. We don't need to create these functions; we just need to call them.
Example : console.log(), Math.sqrt()
Like with functions, we need to use parentheses () with the variable name to call a function expression.

Use a function expression when:
you need a function that isn't hoisted. the function should only used when it is defined. the function is anonymous, or doesn't need a name for later use.

A function declaration can not be called at the same time when it was created, while a function expression can be used as an IIFE which means we can call it immediately after defining it.

In JavaScript, the scope of a variable determines where it can be accessed within the code.
Variables can be declared in different scopes:
Global Scope
Local (Function) Scope
Block-Level Scope

The value of a global variable can be changed inside a function. 

It is a good practice to avoid using global variables because the value of a global variable can change in different areas of the program. This can lead to unknown results.

JavaScript has a strict mode in which a variable cannot be used without declaring it.

24. JavaScript ES6 introduced block-level scoping with the let and const keywords.
Block-level variables are accessible only within the block {} they are defined in, which can be smaller than a function's scope. 

25. hoisting is a behavior in which a function or a variable can be used before declaration. There are generally two types of hoistings in JavaScript:
Variable Hoisting
Function Hoisting

the behavior of hoisting varies depending on whether a variable is declared using var, let, or const.

When we declare a variable using var, it is hoisted to the top of its current scope.
console.log(test);
var test = 5;
// Output: undefined
cause, variable is hoisted with the default value of undefined.

26. When we declare a variable using let or const, it is hoisted to the top of its current scope. However, the variable does not have a default value when it is hoisted (unlike when declared using var).
console.log(message);
let message;
Output : ReferenceError: Cannot access 'message' before initialization.

Here, the error occurs because a variable declared with let is not assigned any default value when hoisted.
We know the message variable was hoisted because the error message "Cannot access 'message' before initialization" indicates that JavaScript is aware that message exists.
Had the variable not been hoisted, we'd get a different error, i.e., ReferenceError: message is not defined.
Initializations Are Not Hoisted.

27. function hoisting allows us to call the function before its declaration.
Function Expressions are not hoisted.
When we use a function expression, we cannot call it before its declaration. 

28. Recursion is a programming technique where a function calls itself repeatedly to solve a problem. 
JavaScript does have a recursion limit.
The recursion limit prevents errors caused by too many nested function calls.
However, the limit varies depending on the JavaScript engine and the environment in which the code is running.
For instance, the maximum limit can differ between Firefox and Chrome. Whereas, devices with higher memory might have higher recursion limits than devices with less memory.

29. When there is no base case in a recursive function, it runs infinitely, resulting in an infinite recursion. 


  *** Objects ***


30. javaScript object is a variable that can store multiple data in key-value pairs.
the key-value pairs of an object are referred to as properties. 

31. functions that are defined inside objects are called methods.
Just like we use () to call a function, we must use () to call methods.

32. We use this keyword in an object method to access a property of the same object. 
JavaScript Built-In Methods : console.log(), prompt(), concat(), toFixed() etc..
use the concat() method to concatenate (join) two strings. 
use the toFixed() method to round off a number into a fixed number of digits.

33. a constructor function is used to create and initialize objects.
// constructor function
function Person () {
    this.name = "John",
    this.age = 23
}

// create an object
const person = new Person();

// print object attributes
console.log(person.name);

Here, Person() is an object constructor function. And, we use the new keyword to create an object from a constructor function.

when this keyword is used in a constructor function, this refers to the specific object in which it is created. 

Object literals are used to create a single object.

On the other hand, constructor functions are useful if you want to create multiple objects.

Objects created from constructor functions are unique. Thus, you can add a new property to a particular object that isn't accessible to other objects.

On the other hand, when an object is created with an object literal, any object variable derived from that object will act as a clone of the original object.

34. JavaScript also has built-in constructors to create objects of various types.
Constructor	Description
Object()	Creates a new object with properties and methods.
String()	Constructs a string object for manipulating and representing textual data.
Number()	Constructs a number object for handling data and operations.
Boolean()	Constructs a boolean object representing true or false values 
             for logical operations.

35. You should not declare strings, numbers, and boolean values as objects because they slow down the program. Instead, declare them as primitive types using code such as let name = "John", let number = 57, etc.

36. In JavaScript, there are two kinds of object properties:
Data properties
Accessor properties

37. Accessor properties are methods that get or set the value of an object. For that, we use these two keywords:
get - to define a getter method to get the property value
set - to define a setter method to set the property value

const person = {
    // data property
    name: 'John',
    age: 23,
    // accessor property(getter)
    get getName() {
        return this.name;
    },
    //accessor property(setter)
    set changeName(newName) {
        this.name = newName;
    }
}

you can also use Object.defineProperty() method to add getters and setters. 
// getting property
Object.defineProperty(student, "getName", {
    get : function () {
        return this.firstName;
    }
});
// setting property
Object.defineProperty(student, "changeName", {
    set : function (value) {
        this.firstName = value;
    }
});

38. In JavaScript, prototypes allow properties and methods to be shared among instances of the function or object.
Properties or methods added to the prototype of a constructor function are accessible to all objects derived from it. 
/ add property
Car.prototype.color = "Red";
// add method
Car.prototype.drive = function() {
    console.log(`Driving ${this.model}`);
};

JavaScript always searches for properties in the objects of the constructor function first. Then, it searches in the prototype.
This process is known as prototype chaining. 

You should never modify the prototype property of standard JavaScript built-in objects like strings, arrays, etc. It can cause major errors in your program.

The usage of the prototype has decreased significantly since the introduction of classes in ES6. However, you can still learn it to improve your understanding of JavaScript.


 *** JS Types ***


39. An array is an object that can store multiple values at once.
Arrays allow us to organize related data by grouping them within a single variable.
Unlike many other programming languages, JavaScript allows us to create arrays with mixed data types.
Each element of an array is associated with a number called an index, which specifies its position inside the array.
Array indexes always start with 0, not 1.

40. The push() method adds zero or more elements to the end of the array.
push() method changes the original array and its length.

The unshift() method adds one or more elements to the beginning of an array and returns the new length of the array.
unshift() method changes the original array and its length.

41. We can add or change elements by accessing the index value. 
You can also create an array using JavaScript's new keyword. 
 It's better to create an array using an array literal [] for greater readability and execution speed.

 42. The pop() method removes the last element from an array and returns that element.
Returns undefined if the array is empty.
This method changes the original array and its length.

The shift() method removes the first element from an array and returns that element.
This method changes the original array and its length.

43. The slice() method returns a shallow copy of a portion of an array into a new array object.
The slice() method takes in:
start (optional) - Starting index of the selection. If not provided, the selection starts at start 0.
end (optional) - Ending index of the selection (exclusive). If not provided, the selection ends at the index of the last element.
slice() Returns a new array containing the extracted elements.

In JavaScript, you can also use negative start and end indices. The index of the last element is -1, the index of the second last element is -2, and so on.

The slice() method shallow copies the elements of the array in the following way:

It copies object references to the new array. (For example, a nested array) So if the referenced object is modified, the changes are visible in the returned new array.
It copies the value of strings and numbers to the new array.

44.  Shallow Copy vs Deep Copy :
In JavaScript, there are two ways to copy objects: shallow copy and deep copy. Shallow copying creates a new object with references to the same memory locations as the original object, while deep copying creates a new object with new memory locations for all of its properties and nested objects or arrays.

Shallow Copy Example :
slice(), [].concat, ... , Array.from

Deep Copy Example :
JSON.parse(JSON.stringify(originalArray)) : only works for arrays / objects without functions or undefined values.
._cloneDeep(originalArray);

45. The splice() method modifies an array (adds, removes or replaces elements).
arr.splice(start, deleteCount, item1, ..., itemN)
start - The index from where the array is changed.
deleteCount (optional) - The number of items to remove from start.
item1, ..., itemN (optional) - The elements to add to the start index. If not specified, splice() will only remove elements from the array.

Returns an array containing the deleted elements.
Note: The splice() method changes the original array.

If start > array.length, splice() does not delete anything and starts appending arguments to the end of the array.
If start < 0, the index is counted from backward (array.length + start). For example, -1 is the last element.
If array.length + start < 0, it will begin from index 0.

If deleteCount is omitted or is greater than the number of elements left in the array, it deletes all elements from start to end of the array.
If deleteCount is 0 or negative, no elements are removed. But, at least one new element should be specified.

46. Array Methods :
JavaScript Array length
Returns the number of elements in an array

JavaScript Array reverse()
Returns the array in reverse order

JavaScript Array sort()
Sorts the elements of an array in specific order

JavaScript Array fill()
Returns array by filling elements with given value

Javascript Array join()
Concatenates the array elements to a string

Javascript Array toString()
Returns the string representation of an array

JavaScript Array pop()
Removes and returns the last array element

JavaScript Array shift()
Removes and returns the first array element

JavaScript Array push()
Adds elements to end of array & returns its length

JavaScript Array unshift()
Adds elements to start of array and returns length

JavaScript Array concat()
Returns array by merging given value and/or arrays

JavaScript Array splice()
Returns an array by changing its elements in place

JavaScript Array lastIndexOf()
Returns the last index of occurrence of an element

JavaScript Array indexOf()
Returns the first index of occurrence of element

JavaScript Array of() Method
Creates a new Array instance from given arguments

JavaScript Array slice()
Returns a shallow copy of a portion of an array

JavaScript Array findIndex()
Returns index of element that satisfies condition

JavaScript Array find()
Returns first element that satisfies a condition

JavaScript Array includes()
Checks if a value exists in an array

Javascript Array reduceRight()
Reduces array to single value from right to left

Javascript Array reduce()
Reduces array to single value from left to right

Javascript Array isArray()
Checks if the given value is a JavaScript Array

Javascript Array filter()
Returns array by filtering elements on given test

JavaScript Array map()
Returns array by mapping elements using given func

Javascript Array forEach()
Executes the given function on array elements

Javascript Array some()
Tests if any element passes given test function

JavaScript Array.every()
Tests if all elements pass the given test function

Javascript Array entries()
Returns iterator containing key/value pair array

JavaScript Array keys()
Returns an iterator containing keys of array items

JavaScript Array values()
Returns iterator containing values of array items

Javascript Array.from()
Creates a new Array from array-like object

Javascript Array constructor
Returns the constructor function for the array

Javascript Array copyWithin()
Copies and overwrites elements within the array

JavaScript Array.toLocaleString()
Returns string representing the elements of array

JavaScript Array flat()
Flattens the nested array to given depth

JavaScript Array flatMap()
Returns new array by mapping and flattening array

47. Multidimensional arrays contain another array inside them.
// contains 3 separate arrays as elements
const data = [[1, 2, 3], [1, 3, 4], [4, 5, 6]];

48. The JavaScript string is a primitive data type that represents textual data.
Access String Characters :
 1. Using Indexes
 2. Using the charAt() Method

 Strings are Immutable.
 Strings are Case-Sensitive

 JavaScript String Methods :
 JavaScript String length
Returns the number of characters in a string

JavaScript String replace()
replace a substring/pattern in the string

JavaScript String indexOf()
Returns the first index of occurrence of a value

JavaScript String lastIndexOf()
Returns the last index of occurrence of a value

Javascript String startsWith()
Checks if a string begins with a specified string

Javascript String endsWith()
Checks if a string ends with a specified string

Javascript String toUpperCase()
Returns uppercase of a string

Javascript String toLowerCase()
Returns lowercase representation of a string

Javascript String includes()
Checks if given string is found inside a string

JavaScript String repeat()
Returns a string by repeating it given times

JavaScript String charAt()
Returns character at a specified index in string

JavaScript String charCodeAt()
Returns Unicode of the character at given index

JavaScript String fromCharCode()
Returns a string from the given UTF-16 code units

Javascript String substring()
Returns a specified part of the string

Javascript String padStart()
Pads a string at the start to a given length

Javascript String padEnd()
Pads a string at the end to a given length

JavaScript String codePointAt()
Returns the Unicode point value at given index

JavaScript String fromCodePoint()
Returns a string using the given code points

Javascript String match()
Returns result of matching string with a regex

Javascript String matchAll()
Returns iterator of results matching with a regex

Javascript String localeCompare()
Compares two strings in the current locale

Javascript String search()
Searches for specified value in the string

JavaScript String replaceAll()
Returns string by replacing all matching patterns

JavaScript String concat()
Concatenates the arguments to the calling string

JavaScript String split()
Returns the string divided into list of substring

JavaScript String trim()
Removes whitespace from both ends of a string

JavaScript String slice()
Extracts and returns a section of the string

49. You use escape characters to insert characters that are difficult or impossible to represent directly in a string.

Code	Character
\"	Double Quote
\\	Backslash
\n	New Line
\r	Carriage Return
\v	Vertical Tab
\t	Horizontal Tab
\b	Backspace
\f	Form feed

50. JavaScript Multiline Strings :
A. Multiline in code but not in the output.
Separating a long string into multiple lines can make your code look clean. You can achieve this using the + or the \ operators.

B. Multiline in both code and output.
Use any of the following to print multiple lines using a single string variable:
Template Literals ` `
Newline Escape Character \n

51. The JavaScript for...in loop iterates over the keys of an object.
You can also use the for...in loop to iterate over string values.
You can also use for...in with arrays. 

52. In JavaScript, numbers are used to represent numerical values. They can be whole numbers (like 5, 10, 100) or decimal numbers (like 3.13, 0.5, 10.75).

53. NaN (Not a Number) is a special value that is returned when a mathematical operation cannot produce a meaningful numeric result.
Performing arithmetic operations (except addition) on numeric values and strings results in NaN. For example,
let num = 4 - "hello";
console.log(num); // NaN

When the typeof operator is used for NaN value, it gives number as an output.

The built-in isNaN() function can be used to find if a value is a number.

54. Infinity is a special value that signifies an amount larger than any finite number.
dividing a positive number by 0 yields Infinity, while dividing a negative number by 0 results in -Infinity.

55. Exponential Numbers :
You can use the exponential notation e to represent numbers that are very large or very small.
let num1 = 5e9;
console.log(num1);  // 5000000000

56. The hexadecimal number system is a type of number system, that has a base value equal to 16. It is also pronounced sometimes as 'hex'. Hexadecimal numbers are represented by only 16 symbols. These symbols or values are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E and F. Each digit represents a decimal value.

Decimal : Hexadecimal
0 - 9 : 0 - 9 (Same)
10 : A 
11 : B 
12 : C 
13 : D 
14 : E 
15 : F 

JavaScript Numbers can also be denoted in hexadecimal notation. For example,
let num1 = 0xff; // it always starts with 0x in JS.
console.log(num1);  // 255

57. An integer is a whole number (not a fractional number) that can be positive, negative, or zero. 
JavaScript Number.isSafeInteger()
A safe integer is an integer that can be exactly represented as an IEEE-754 double precision number [ all integers from (253 - 1) to -(253 - 1) ].

58. 
Method	Description
isNaN()	Determines whether the passed value is NaN.
isFinite()	Determines whether the passed value is a finite number.
isInteger()	Determines whether the passed value is an integer.
isSafeInteger()	Determines whether the passed value is a safe integer.
parseFloat()	Converts the numeric floating string to a floating-point number.
parseInt()	Converts the numeric string to an integer.
toExponential()	Returns a string value for a number in exponential notation.
toFixed()	Returns a string value for a number in fixed-point notation.
toPrecision()	Returns a string value for a number to a specified precision.
toString()	Returns a string value in a specified radix (base).
valueOf()	Returns the number's value.
toLocaleString()	Returns a string with a language-sensitive representation of a number.

59. JavaScript Precision Problems :
In JavaScript, numbers (especially decimals) aren't always stored accurately, leading to precision problems. For example,
let num = 0.1 + 0.2;
console.log(num); // 0.30000000000000004

The result should be 0.3 instead of 0.3000000000004.
This error occurs because JavaScript stores numbers in binary form to represent decimal digits. And decimal numbers can't be represented in binary form exactly.
We can mitigate the precision problem in the following ways:

A. Converting Floating-Point Numbers to Integers
let num = (0.1 * 10 + 0.2 * 10) / 10;
console.log(num); // 0.3

B.  Using the toFixed() Method :
let num = 0.1 + 0.2;
console.log(num.toFixed(2)); // 0.30

60. JavaScript BigInt :
The number type can only represent values less than (2^53 - 1) 
and more than -(2^53 - 1).
However, if you need to use a larger or smaller number than that, you can use the BigInt data type. BigInt allows you to do calculations with any size or precision.
A BigInt number is created by appending n to the end of an integer. For example,
// BigInt value
let value = 900719925124740998n;
// add two big integers
let value1 = value + 1n;
console.log(value1);
// Output: 900719925124740999n

61. The Number() function converts data of various types to numbers. 
Number objects can be created using the new keyword.

62. The JavaScript ES6 introduced a new primitive data type called Symbol. Symbols are immutable (cannot be changed) and are unique.
You use the Symbol() function to create a Symbol. 


*** Exception and Modules ***


63. JavaScript try...catch...finally Statement :
The try, catch and finally blocks are used to handle exceptions (a type of an error).
In programming, there can be two types of errors in the code:

Syntax Error: Error in the syntax. For example, if you write consol.log('your result');, the above program throws a syntax error. The spelling of console is a mistake in the above code.

Runtime Error: This type of error occurs during the execution of the program. For example,
calling an invalid function or a variable.

These errors that occur during runtime are called exceptions. Now, let's see how you can handle these exceptions.

try {
    // try_statements
} 
catch(error) {
    // catch_statements  
}
finally() {
    // codes that gets executed anyway
}

The main code is inside the try block. While executing the try block, if any error occurs, it goes to the catch block. The catch block handles the errors as per the catch statements.
If no error occurs, the code inside the try block is executed and the catch block is skipped.
The finally block will execute in any situation ( if the program runs successfully or if an error occurs).
Note: You need to use catch or finally statement after try statement. Otherwise, the program will throw an error Uncaught SyntaxError: Missing catch or finally after try.

You can also use the throw statement with the try...catch statement to use user-defined exceptions. For example, a certain number is divided by 0. If you want to consider Infinity as an error in the program, then you can throw a user-defined exception using the throw statement to handle that condition.
The throw expression can be string, boolean, number, or object value.

You can also use other built-in error constructors for standard errors: TypeError, SyntaxError, ReferenceError, EvalError, InternalError, and RangeError.
throw new ReferenceError('this is reference error');

You can also use throw statement inside the catch block to rethrow an exception.

64. The try...catch won't catch the exception if it happened in "timed" code, like in setTimeout(). For example,

try {
    setTimeout(function() {
        // error in the code
    }, 3000);
} catch (e) {
  console.log( "won't work" );
}
The above try...catch won't work because the engine has already left the try..catch constructors and the function is executed later.

The try..catch block must be inside that function to catch an exception inside a timed function. For example,

setTimeout(function() {
    try {
        // error in the code
    } catch {
        console.log( "error is caught" );
    }
}, 3000);

65. Module is a file that contains code to perform a specific task. A module may contain variables, function, classes etc. 
export const name = 'JavaScript Program';
export function sum(x, y) {
    return x + y;
}
import { name, sum } from './module.js';

// renaming import inside module.js
export {
    function1 as newName1,
    function2 as newName2
};
import { newName1, newName2 } from './module.js';

 A file can contain multiple exports. However, you can only have one default export in a file.

 By default, modules are in strict mode. 


 *** JavaScript ES6 ***


 66. JavaScript ES6 (also known as ECMAScript2015 or ECMAScript6) is the sixth edition of JavaScript introduced in June 2015.

ECMAScript (European Computer Manufacturers Association Script) is the standard specification of JavaScript to ensure compatibility in all browsers and environments.

ES6 now allows you to declare variables using two more keywords: let and const.

The let keyword creates block-scoped variables, which means they are only accessible within a particular block of code. 
The const keyword creates constant variables that cannot be changed after declaration. 

67. JavaScript Arrow Functions are a concise syntax for writing function expressions.
// regular function 
let multiply = function(x, y) {
    return x * y;
};
// arrow function
let multiply = (x, y) => x * y;

If a function body has multiple statements, you need to put them inside curly brackets {}.

Inside a regular function, this keyword refers to the function where it is called.
However, this is not associated with arrow functions. So, whenever you call this, it refers to its parent scope.

Things You Should Avoid With Arrow Functions :

A. You should not use arrow functions to create methods inside objects.
let person = {
    name: "Jack",
    age: 25,
    sayName: () => {
        console.log(this.age);
    }
}
person.sayName(); // undefined

B. You cannot use an arrow function as a constructor.
let Foo = () => {};
let foo = new Foo();
// Output: TypeError: Foo is not a constructor

68. Starting from JavaScript ES6, we can provide default values for function parameters.
These default values are used when the function is called without passing the corresponding arguments.

69. JavaScript template literals are strings that allow us to embed variables or expressions directly within them. They are enclosed in backticks ``.
Hello ${name}` is a template literal and we have embedded the name variable directly within it.

${number1 + number2} is the embedded expression.
${number1} and ${number2} are the embedded variables.

Template literals allow any type of quotes to be included directly.
Create multiline strings using template literals.

Tagged templates are an advanced form of template literals in JavaScript. They allow you to parse template literals with a function.
Furthermore, you don't need to use parentheses () when passing the template literal to the function. For example,
function displayMessage(message) {
    return message;
}
// create a tagged template
let result = displayMessage`Hello Jack`
console.log(result);  // [ 'Hello Jack' ]

Here, unlike regular function arguments, the template literal is split into an array.
In our example, the function received an array with a single element (the string from the template literal). So, we obtained [ 'Hello Jack' ] as an output.

70. The JavaScript spread operator ... is used to expand or spread out elements of an iterable, such as an array, string, or object.
This makes it incredibly useful for tasks like combining arrays, passing elements to functions as separate arguments, or even copying arrays.

Clone Array Using Spread Operator.
You can also use the spread operator with object literals.

71. When the spread operator is used as a parameter, it is known as the rest parameter.
You can accept multiple arguments in a function call using the rest parameter.
Using the rest parameter will pass the arguments as array elements.
You can also use the spread operator as part of a function argument. 
If you pass multiple arguments using the spread operator, the function takes the required number of arguments and ignores the rest.

72. The JavaScript ES6 has introduced two new data structures, i.e Map and WeakMap.
Map is similar to objects in JavaScript that allows us to store elements in a key/value pair.
The elements in a Map are inserted in an insertion order. However, unlike an object, a map can contain objects, functions and other data types as key.

// create a set
let map1 = new Map();
// insert key-value pair
map1.set('info', {name: 'Jack', age: 26});
console.log(map1); // Map {"info" => {name: "Jack", age: 26}}

you can use the set() method to insert elements to map.
You can access Map elements using the get() method. 
You can use the has() method to check if the element is in a Map.
You can use the clear() and the delete() method to remove elements from a Map.
The delete() method returns true if a specified key/value pair exists and has been removed or else returns false.
The clear() method removes all key/value pairs from a Map object. 
You can get the number of elements in a Map using the size property. 
You can iterate through the Map elements using the for...of loop or forEach() method. The elements are accessed in the insertion order. 
You can iterate over the Map and get the key using the key() method. 
You can iterate over the Map and get the values using the values() method. 
You can iterate over the Map and get the key/value of a Map using the entries() method.

73. JavaScript Map vs Object :
Maps can contain objects and other data types as keys.	Objects can only contain strings and symbols as keys.
Maps can be directly iterated and their value can be accessed.	Objects can be iterated by accessing its keys.
The number of elements of a Map can be determined by size property.	The number of elements of an object needs to be determined manually.
Map performs better for programs that require the addition or removal of elements frequently.	Object does not perform well if the program requires the addition or removal of elements frequently.

74. The WeakMap is similar to a Map. However, WeakMap can only contain objects as keys.
When you try to add other data types besides objects, WeakMap throws an error.
Unlike Maps, WeakMaps are not iterable. 

75. The JavaScript ES6 has introduced two new data structures, i.e Set and WeakSet.
Set is similar to an array that allows us to store multiple items like numbers, strings, objects, etc. However, unlike an array, a set cannot contain duplicate values.

To create a Set, you need to use the new Set() constructor. 
You can access Set elements using the values() method and check if there is an element inside Set using has() method. 
const set1 = new Set([1, 2, 3, 3, 4]);
always pass value in [], inside set.

You can add elements to a Set using the add() method.
The delete() method removes a specific element from a Set. 
The clear() method removes all elements from a Set.

You can iterate through the Set elements using the for...of loop or forEach() method. The elements are accessed in the insertion order.

76. The WeakSet is similar to a Set. However, WeakSet can only contain objects whereas a Set can contain any data types such as strings, numbers, objects, etc.
When you try to add other data types besides objects, WeakSet throws an error. 

WeakSets have methods add(), delete(), and has().
Unlike Sets, WeakSets are not iterable.

77. Mathematical Set Operations
In JavaScript, Set does not provide built-in methods for performing mathematical operations such as union, intersection, difference, etc. However, we can create programs to perform those operations.

78. The destructuring assignment introduced in ES6 makes it easy to assign array values and object properties to distinct variables. 
// destructuring assignment
let { name, age, gender } = person;
 The order of the name does not matter in object destructuring.
 Note: When destructuring objects, you should use the same name for the variable as the corresponding object key.
 If you want to assign different variable names for the object key, you can use:
 let { name: name1, age: age1, gender:gender1 } = person;

 You can also perform array destructuring in a similar way. 
 const [x, y, z] = arrValue;

You can assign the default values for variables while using destructuring. 
let arrValue = [10];
// assigning default value 5 and 7
let [x = 5,  y = 7] = arrValue;

You can skip unwanted items in an array without assigning them to local variables. For example,
const [x, , z] = arrValue;

You can assign the remaining elements of an array to a variable using the spread syntax .... 
The variable with the spread syntax cannot have a trailing comma ,. You should use this rest element (variable with spread syntax) as the last variable.
let { name, ...rest } = person;

You can perform nested destructuring for array elements.
// nested array elements
const arrValue = ['one', ['two', 'three']];
// nested destructuring assignment in arrays
const [x, [y, z]] = arrValue;

79. In JavaScript ES6, classes provide a way to create blueprints for objects, similar to traditional object-oriented programming languages like C++ or Java.
